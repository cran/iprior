<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Haziq Jamil" />

<meta name="date" content="2017-11-02" />

<title>Closed-form EM algorithm matrix manipulations</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Closed-form EM algorithm matrix
manipulations</h1>
<h4 class="author">Haziq Jamil</h4>
<h4 class="date">2017-11-02</h4>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>The M-step involving the scale parameters <span class="math inline">\(\boldsymbol\lambda\)</span> in the EM algorithm
for I-prior models can be found in closed-form in the following
situations:</p>
<ol style="list-style-type: decimal">
<li>A single scale parameter <code>lambda</code> being used.</li>
<li>Non-parsimonious methods for higher-order terms and
interactions.</li>
<li>Parsimonious methods, but no covariates involving square, cubic or
any other higher order terms, and the highest interaction order is
two.</li>
</ol>
<p>For any other models such as ones involving squared terms and
three-way interactions, the M-step can still be solved using numerical
methods such as a downhill simplex method (in R, we use
<code>optim(method = &quot;Nelder-Mead&quot;)</code>. Examples:</p>
<table>
<thead>
<tr class="header">
<th>Model</th>
<th><code>parsm</code></th>
<th><code>length(lambda)</code></th>
<th>Closed form?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>y ~ x1 + x2 + x3</code></td>
<td><code>TRUE</code></td>
<td>3</td>
<td>Yes</td>
</tr>
<tr class="even">
<td><code>y ~ (x1 + x2 + x3)</code></td>
<td><code>TRUE</code></td>
<td>1</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td><code>y ~ x1 + x2 + x1:x2</code></td>
<td><code>TRUE</code></td>
<td>2</td>
<td>Yes</td>
</tr>
<tr class="even">
<td><code>y ~ x1 + x2 + x1:x2</code></td>
<td><code>FALSE</code></td>
<td>3</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td><code>y ~ (x1 * x2 * x3)</code></td>
<td><code>TRUE</code></td>
<td>1</td>
<td>Yes</td>
</tr>
<tr class="even">
<td><code>y ~ x1 * x2 * x3</code></td>
<td><code>FALSE</code></td>
<td>7</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td><code>y ~ x1 + I(x1 ^ 2)</code></td>
<td><code>FALSE</code></td>
<td>2</td>
<td>Yes</td>
</tr>
<tr class="even">
<td><code>y ~ x1 * x2 * x3</code></td>
<td><code>TRUE</code></td>
<td>3</td>
<td>No</td>
</tr>
<tr class="odd">
<td><code>y ~ x1 + I(x1 ^ 2)</code></td>
<td><code>TRUE</code></td>
<td>1</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>In short, the most complex model for which closed-form for
<code>lambda</code> exists is the parsimonious two-way interaction
model. We describe this below.</p>
<p>Assume there are <span class="math inline">\(p\)</span> covariates,
and each of the <span class="math inline">\(p\)</span> kernel matrices
<span class="math inline">\(\mathbf H_1, \dots, \mathbf H_p\)</span> are
calculated using the appropriate kernels, depending on whether the data
is continuous or nominal and what effect is desired. Let the number of
unique scale parameters be <span class="math inline">\(l \leq
p\)</span>. <span class="math inline">\(l\)</span> could be less than
<span class="math inline">\(p\)</span>, which implies that some of the
covariates share a scale parameter. For a group of such covariates, the
kernel matrix is simply the sum of each kernel matrix, and thus the
kernel matrices can be indexed from <span class="math inline">\(1,
\dots, l\)</span> as well. Otherwise <span class="math inline">\(l =
p\)</span>.</p>
<p>If two-way interactions are present between any <span class="math inline">\(k,j \in \{1,\dots,l\}\)</span>, then these are
also calculated as <span class="math inline">\(\mathbf H_{kj} = \mathbf
H_k \circ \mathbf H_j\)</span> (the Hadamard product). In general, the
scaled kernel matrix looks like <span class="math display">\[
    \mathbf H_{\lambda} = \sum_{k=1}^l \lambda_k \mathbf H_k +
\sum_{k,j\in M} \lambda_k\lambda_j \mathbf H_{kj}
\]</span> where the set <span class="math inline">\(M\)</span> is the
index of all two way interaction terms between the <span class="math inline">\(p\)</span> covariates, i.e. <span class="math inline">\(M\)</span> <span class="math inline">\(=\)</span>
<span class="math inline">\(\{(k,j):\)</span> <span class="math inline">\(k \text{ interacts with } j,\)</span> <span class="math inline">\(\text{ and }\)</span> <span class="math inline">\(k &lt; j,\)</span> <span class="math inline">\(\\\)</span> <span class="math inline">\(\forall
k,j=1,\dots,l \}\)</span>. Let the number of two-way interactions be
<span class="math inline">\(m=|M|\)</span>. The total number of scale
parameters is equal to <span class="math inline">\(q=l+m\)</span> when
there are non-parsimonious interactions present, otherwise it is <span class="math inline">\(q=l\)</span>. The non-parsimonious method of
interactions assigns a new scale parameter for each of the Hadamard
products of interacting kernel matrices. In comparison, the parsimonious
method simply multiplies the corresponding scale parameters
together.</p>
<p>For a particular <span class="math inline">\(\lambda_k\)</span>,
<span class="math inline">\(k \in \{1,\dots,q\}\)</span>, we partition
the sum of the kernel matrix into parts which involve <span class="math inline">\(\lambda_k\)</span> and parts which do not: <span class="math display">\[
\begin{aligned}
    \mathbf H_\lambda &amp;=
    \overbrace{\lambda_k \left( \mathbf H_k +  \sum_{j\in
M}\lambda_j\mathbf H_{kj} \right) \vphantom{\mathop{\sum_{j=1}^p}_{j\neq
k}}}^{\lambda_k\text{ is here}}
    +
    \overbrace{{\mathop{\sum_{j=1}^l}_{j\neq k}\lambda_j \mathbf H_j} +
{\mathop{\sum_{k&#39;,j \in M}}_{k&#39;\neq k}\lambda_{k&#39;}\lambda_j
\mathbf H_{k&#39;j}}}^{\text{no $\lambda_k$ here}} \\
    &amp;= \lambda_k\mathbf {P_k} + {\mathbf R_k} + {\mathbf U_k}.
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\mathbf P_k\)</span> is the kernel matrix
<span class="math inline">\(\mathbf H_k\)</span> plus the sum-product of
the interaction kernel matrices with the scale parameters relating to
covariate <span class="math inline">\(k\)</span>, i.e. <span class="math inline">\(\sum_j \lambda_j\mathbf H_{kj}\)</span>. <span class="math inline">\(\mathbf R_k\)</span> is the sum-product of the
kernel matrices and scale parameters excluding <span class="math inline">\(\lambda_k\mathbf H_k\)</span>. <span class="math inline">\(\mathbf U_k\)</span> is the sum of the interaction
cross-product terms excluding those relating to covariate <span class="math inline">\(k\)</span>. Thus, the squared kernel matrix is
<span class="math display">\[
\begin{align}
        \mathbf H_{\lambda}^2 =&amp; \ \lambda_k^2\mathbf P_k^2  +
\lambda_k(\mathbf P_k\mathbf R_k + (\mathbf P_k\mathbf R_k)^\top +
\mathbf P_k\mathbf U_k + (\mathbf P_k\mathbf U_k)^\top) \nonumber \\
        &amp; + \mathbf R_k^2 + \mathbf U_k^2 + \mathbf R_k\mathbf U_k +
\mathbf U_k\mathbf R_k.
\end{align}
\]</span></p>
<p>The closed-form solution for the scale parameters in the M-step at
iteration <span class="math inline">\(t\)</span> is <span class="math display">\[
    \lambda_k^{(t+1)} = \frac{(\mathbf y - \hat{\boldsymbol\alpha})^\top
\mathbf P_k \tilde{\mathbf w}^{(t)} - \frac{1}{2} \text{tr} \left[
\mathbf S_k \tilde{\mathbf W}^{(t)} \right]}{\text{tr} \left[ \mathbf
P_k^2 \tilde{\mathbf W}^{(t)} \right]}
\]</span> where we have defined <span class="math inline">\(\mathbf S_k
= \mathbf P_k\mathbf R_k + \mathbf R_k\mathbf P_k + \mathbf P_k\mathbf
U_k + \mathbf U_k\mathbf P_k\)</span>, for each <span class="math inline">\(k = 1,\dots,l\)</span>.</p>
<p>For most cases, <span class="math inline">\(\mathbf P_k\)</span> and
<span class="math inline">\(\mathbf S_k\)</span> only depend on the
kernel matrices and not on the scale parameters, so can be calculated
once and stored for efficiency. Further, <span class="math inline">\(\mathbf U_k\)</span> equals zero for most cases
except in the parsimonious multiple scale parameter case thus
simplifying calculations. In fact, we can avoid the expensive matrix
multiplications involved in evaluating <span class="math inline">\(\mathbf P_k\)</span>, its square, and <span class="math inline">\(\mathbf S_k\)</span>, by storing all possible
square and two-way multiplications of the kernel matrices <span class="math inline">\(\mathbf H_1, \dots, \mathbf H_l\)</span> as the
relevant calculation of the M-step simply involves a sum-product of
these kernel matrices.</p>
</div>
<div id="the-code" class="section level2">
<h2>The code</h2>
<p><code>intr</code> is always a <code>2 x m</code> matrix indexing all
the <code>m</code> two-way interactions in the model.</p>
<p><code>h</code> is the length of the kernel matrix. If there are
<code>p</code> variables, and <code>m</code> two-way interactions, then
<code>h</code> contains the <code>p</code> kernel matrices, and
<code>m</code> Hadamard products between the kernel matrices according
to the <code>intr</code> indices. Thus <code>h = p + m</code>,
regardless of parsimonious or non-parsimonious interactions.</p>
<p><code>ind1</code> and <code>ind2</code> together give the index of
all possible two-way interactions. In a <code>h x h</code> matrix, these
are the row (<code>ind1</code>) and column (<code>ind2</code>) indices
of the upper triangular matrix excluding the diagonal entries.</p>
<p>The goal is to efficiently compute a list of length <code>h</code>
which contains the <code>H.mat_i ^ 2</code> for
<code>i = 1,...,h</code>. Incidentally, we have used <code>q</code> to
denote the expanded <code>lambda</code> length which includes
interactions and higher order terms, so <code>q=l+m</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>indxFn <span class="ot">&lt;-</span> <span class="cf">function</span>(k) {</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  <span class="co"># Indexer helper function used to create indices for H2l. Note: intr, ind1 and</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>  <span class="co"># ind2 are created in kernL().</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>  ind.int1 <span class="ot">&lt;-</span> intr[<span class="dv">1</span>, ] <span class="sc">==</span> k; ind.int2 <span class="ot">&lt;-</span> intr[<span class="dv">2</span>, ] <span class="sc">==</span> k  <span class="co"># locating var/kernel matrix</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>  ind.int <span class="ot">&lt;-</span> <span class="fu">which</span>(ind.int1 <span class="sc">|</span> ind.int2)                   <span class="co"># of interactions (out of 1:no.int)</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>  k.int <span class="ot">&lt;-</span> ind.int <span class="sc">+</span> p  <span class="co"># which kernel matrix has interactions involving k</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>  k.int.lam <span class="ot">&lt;-</span> <span class="fu">c</span>(intr[<span class="dv">1</span>, ][ind.int2], intr[<span class="dv">2</span>, ][ind.int1])  <span class="co"># which has </span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>                                                            <span class="co"># interaction with k?</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>  nok <span class="ot">&lt;-</span> (<span class="dv">1</span><span class="sc">:</span>p)[<span class="sc">-</span>k]  <span class="co"># all variables excluding k</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>  k.noint <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="sc">!</span>(ind.int1 <span class="sc">|</span> ind.int2)) <span class="sc">+</span> p  <span class="co"># the opposite of k.int</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>  <span class="co"># P.mat %*% R.mat + R.mat %*% P.mat indices ----------------------------------</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>  za <span class="ot">&lt;-</span> <span class="fu">which</span>((ind1 <span class="sc">%in%</span> k <span class="sc">&amp;</span> ind2 <span class="sc">%in%</span> nok) <span class="sc">|</span> (ind2 <span class="sc">%in%</span> k <span class="sc">&amp;</span> ind1 <span class="sc">%in%</span> nok))</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>  grid.PR <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(k.int, nok)</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>  zb <span class="ot">&lt;-</span> <span class="fu">which</span>((ind1 <span class="sc">%in%</span> grid.PR[,<span class="dv">1</span>] <span class="sc">&amp;</span> ind2 <span class="sc">%in%</span> grid.PR[,<span class="dv">2</span>]) <span class="sc">|</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>              (ind2 <span class="sc">%in%</span> grid.PR[,<span class="dv">1</span>] <span class="sc">&amp;</span> ind1 <span class="sc">%in%</span> grid.PR[,<span class="dv">2</span>]))</span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>  grid.PR.lam <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(k.int.lam, nok)</span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a>  <span class="co"># P.mat %*% U.mat + U.mat %*% P.mat indices ----------------------------------</span></span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a>  grid.PU1 <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(k, k.noint)</span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a>  zc <span class="ot">&lt;-</span> <span class="fu">which</span>((ind1 <span class="sc">%in%</span> grid.PU1[,<span class="dv">1</span>] <span class="sc">&amp;</span> ind2 <span class="sc">%in%</span> grid.PU1[,<span class="dv">2</span>]) <span class="sc">|</span></span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a>              (ind2 <span class="sc">%in%</span> grid.PU1[,<span class="dv">1</span>] <span class="sc">&amp;</span> ind1 <span class="sc">%in%</span> grid.PU1[,<span class="dv">2</span>]))</span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a>  grid.PU2 <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(k.int, k.noint)</span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a>  zd <span class="ot">&lt;-</span> <span class="fu">apply</span>(grid.PU2, <span class="dv">1</span>, findH2, <span class="at">ind1 =</span> ind1, <span class="at">ind2 =</span> ind2)</span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a>  grid.PU.lam <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(k.int.lam, k.noint)</span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a>  <span class="co"># P.mat %*% P.mat indices ----------------------------------------------------</span></span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a>  grid.Psq <span class="ot">&lt;-</span> <span class="fu">t</span>(<span class="fu">combn</span>(<span class="fu">c</span>(k, k.int), <span class="dv">2</span>))</span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a>  ze <span class="ot">&lt;-</span> <span class="fu">apply</span>(grid.Psq, <span class="dv">1</span>, findH2, <span class="at">ind1 =</span> ind1, <span class="at">ind2 =</span> ind2 )</span>
<span id="cb1-30"><a href="#cb1-30" tabindex="-1"></a>  grid.Psq.lam <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb1-31"><a href="#cb1-31" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">length</span>(k.int.lam) <span class="sc">&gt;</span> <span class="dv">0</span>) grid.Psq.lam <span class="ot">&lt;-</span> <span class="fu">t</span>(<span class="fu">combn</span>(<span class="fu">c</span>(<span class="dv">0</span>, k.int.lam), <span class="dv">2</span>))</span>
<span id="cb1-32"><a href="#cb1-32" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" tabindex="-1"></a>  <span class="fu">list</span>(</span>
<span id="cb1-34"><a href="#cb1-34" tabindex="-1"></a>    <span class="at">k.int     =</span> k.int,</span>
<span id="cb1-35"><a href="#cb1-35" tabindex="-1"></a>    <span class="at">k.int.lam =</span> k.int.lam,</span>
<span id="cb1-36"><a href="#cb1-36" tabindex="-1"></a>    <span class="at">PRU       =</span> <span class="fu">c</span>(za,zc,zb,zd),</span>
<span id="cb1-37"><a href="#cb1-37" tabindex="-1"></a>    <span class="at">PRU.lam1  =</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">0</span>, <span class="fu">length</span>(nok) <span class="sc">+</span> <span class="fu">length</span>(k.noint)),</span>
<span id="cb1-38"><a href="#cb1-38" tabindex="-1"></a>                  grid.PR.lam[,<span class="dv">1</span>], grid.PU.lam[,<span class="dv">1</span>]),</span>
<span id="cb1-39"><a href="#cb1-39" tabindex="-1"></a>    <span class="at">PRU.lam2  =</span> <span class="fu">c</span>(nok, k.noint, grid.PR.lam[,<span class="dv">2</span>], grid.PU.lam[,<span class="dv">2</span>]),</span>
<span id="cb1-40"><a href="#cb1-40" tabindex="-1"></a>    <span class="at">Psq       =</span> <span class="fu">c</span>(k, k.int),</span>
<span id="cb1-41"><a href="#cb1-41" tabindex="-1"></a>    <span class="at">Psq.lam   =</span> k.int.lam,</span>
<span id="cb1-42"><a href="#cb1-42" tabindex="-1"></a>    <span class="at">P2        =</span> ze,</span>
<span id="cb1-43"><a href="#cb1-43" tabindex="-1"></a>    <span class="at">P2.lam1   =</span> grid.Psq.lam[,<span class="dv">1</span>],</span>
<span id="cb1-44"><a href="#cb1-44" tabindex="-1"></a>    <span class="at">P2.lam2   =</span> grid.Psq.lam[,<span class="dv">2</span>]</span>
<span id="cb1-45"><a href="#cb1-45" tabindex="-1"></a>    )</span>
<span id="cb1-46"><a href="#cb1-46" tabindex="-1"></a>}</span>
<span id="cb1-47"><a href="#cb1-47" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" tabindex="-1"></a>findH2 <span class="ot">&lt;-</span> <span class="cf">function</span>(z, ind1, ind2){</span>
<span id="cb1-49"><a href="#cb1-49" tabindex="-1"></a>  <span class="co"># This function finds position of H2 (cross-product terms of H). Used in</span></span>
<span id="cb1-50"><a href="#cb1-50" tabindex="-1"></a>  <span class="co"># indxFn()</span></span>
<span id="cb1-51"><a href="#cb1-51" tabindex="-1"></a>  x <span class="ot">&lt;-</span> z[<span class="dv">1</span>]; y <span class="ot">&lt;-</span> z[<span class="dv">2</span>]</span>
<span id="cb1-52"><a href="#cb1-52" tabindex="-1"></a>  <span class="fu">which</span>((ind1 <span class="sc">==</span> x <span class="sc">&amp;</span> ind2 <span class="sc">==</span> y) <span class="sc">|</span> (ind2 <span class="sc">==</span> x <span class="sc">&amp;</span> ind1 <span class="sc">==</span> y))</span>
<span id="cb1-53"><a href="#cb1-53" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div id="example" class="section level2">
<h2>Example</h2>
<p>Regression with 3 covariates and two-way interactions between all 3
covariates. Here, <code>p = 3</code>, <code>l = 3</code> and
<code>h = q = 6</code>. In full, the index of the <code>H.mat</code> is
<code>c(1, 2, 3, 1:2, 1:3, 2:3)</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>(mod <span class="ot">&lt;-</span> <span class="fu">kernL</span>(stack.loss <span class="sc">~</span> . <span class="sc">^</span> <span class="dv">2</span>, <span class="at">data =</span> stackloss))</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="do">## Sample size: 21 </span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="do">## No. of covariates: 3 </span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="do">## Object size: 251.1 kB</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="do">## Kernel matrices:</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="do">##  1 linear [1:21, 1:21] 383 383 285.2 30.8 30.8 ... </span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="do">##  2 linear [1:21, 1:21] 34.87 34.87 23.06 17.15 5.34 ... </span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="do">##  3 linear [1:21, 1:21] 7.37 4.65 10.08 1.94 1.94 ... </span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="do">##  4 linear x linear [1:21, 1:21] 13355 13355 6575 528 164 ... </span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="do">##  5 linear x linear [1:21, 1:21] 2822 1782.3 2875.1 59.6 59.6 ... </span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a><span class="do">##  6 linear x linear [1:21, 1:21] 256.9 162.2 232.4 33.3 10.4 ... </span></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a><span class="do">## Hyperparameters to estimate:</span></span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a><span class="do">## lambda[1], lambda[2], lambda[3], psi</span></span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a><span class="do">## Estimation methods available:</span></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a><span class="do">## direct, em, canonical, mixed, fixed</span></span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="dv">3</span></span></code></pre></div>
<p>The index of all two-way interactions are obtained by the kernel
loader function. It is contained in <code>model$intr</code>. The
following shows the indices of the variables which have two-way
interactions. For example, variable 1 interacts with variable 2,
variable 1 with 3 and finally 2 with 3. This matrix will always have 2
rows, and columns equal to <code>m</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>intr <span class="ot">&lt;-</span> mod<span class="sc">$</span>intr</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="fu">colnames</span>(intr) <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>intr</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="do">##      [,1] [,2] [,3]</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="do">## [1,]    1    1    2</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="do">## [2,]    2    3    3</span></span></code></pre></div>
<p>Next, we list out the indices of all possible two-way terms. This is
used to compute the cross-product when multilpying out the square of a
sum of matrices.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>h <span class="ot">&lt;-</span> <span class="fu">length</span>(mod<span class="sc">$</span>Hl)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>z <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span>h</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>(ind1 <span class="ot">&lt;-</span> <span class="fu">rep</span>(z, <span class="at">times =</span> (<span class="fu">length</span>(z) <span class="sc">-</span> <span class="dv">1</span>)<span class="sc">:</span><span class="dv">0</span>))</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="do">## [1] 1 1 2</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>(ind2 <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">lapply</span>(<span class="dv">2</span><span class="sc">:</span><span class="fu">length</span>(z), <span class="cf">function</span>(x) <span class="fu">c</span>(<span class="cn">NA</span>, z)[<span class="sc">-</span>(<span class="dv">0</span><span class="sc">:</span>x)])))</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="do">## [1] 2 3 3</span></span></code></pre></div>
<div id="indexing-the-kernel-matrrix-list-hl" class="section level3">
<h3>Indexing the kernel matrrix list <code>Hl</code></h3>
<p>All of the above would be performed in <code>kernL()</code> so
<code>ind1</code> and <code>ind2</code> would be available in
environment. We now enter the <code>indxFn()</code> function. Set
<code>k = 1</code>. First find the index for which variable
<code>k</code> has interactions (in relation to the positioning in
<code>intr</code>). Variable 1 appears in columns 1 and 2 of
<code>intr</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>ind.int1 <span class="ot">&lt;-</span> intr[<span class="dv">1</span>, ] <span class="sc">==</span> k; ind.int2 <span class="ot">&lt;-</span> intr[<span class="dv">2</span>, ] <span class="sc">==</span> k</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>(ind.int <span class="ot">&lt;-</span> <span class="fu">which</span>(ind.int1 <span class="sc">|</span> ind.int2))</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="do">## [1] 1 2</span></span></code></pre></div>
<p>Which of the Hadamard products (i.e. <code>intr</code>) involve
variable <code>k</code>, and where are the relevant Hadamard products in
relation to the full index? The reason for the formula below is that the
Hadamard products are calculated in the same order that appears in
<code>intr</code>, and we add <code>p</code> because the first
<code>p</code> elements are the <code>p</code> kernel matrices.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>(k.int <span class="ot">&lt;-</span> ind.int <span class="sc">+</span> p)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="do">## [1] 4 5</span></span></code></pre></div>
<p>Which variables have interaction with variable <code>k</code>? When I
wrote this, I was thinking which of the <span class="math inline">\(\lambda_j\)</span> need to be multipled by <span class="math inline">\(\lambda_k\)</span>, <span class="math inline">\(j
\neq k\)</span>? In other words, what are the other half of the pair of
variable <code>k</code> in the matrix <code>intr</code>?</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>(k.int.lam <span class="ot">&lt;-</span> <span class="fu">c</span>(intr[<span class="dv">1</span>, ][ind.int2], intr[<span class="dv">2</span>, ][ind.int1]))</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="do">## [1] 2 3</span></span></code></pre></div>
<p>Next I simply call <code>nok</code> the indices of all variables
excluding <code>k</code>. <em>sidenote: I am beginning to think that
<code>k.int.lam == nok</code></em>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>(nok <span class="ot">&lt;-</span> (<span class="dv">1</span><span class="sc">:</span>p)[<span class="sc">-</span>k])</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="do">## [1] 2 3</span></span></code></pre></div>
<p>Finally, these are the indices of the Hadamard products which do not
involve variable <code>k</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>(k.noint <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="sc">!</span>(ind.int1 <span class="sc">|</span> ind.int2)) <span class="sc">+</span> p)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="do">## [1] 6</span></span></code></pre></div>
</div>
<div id="indices-for-mathbf-p_k-mathbf-r_k-mathbf-p_k-mathbf-r_ktop" class="section level3">
<h3>Indices for <span class="math inline">\(\mathbf P_k \mathbf R_k +
(\mathbf P_k \mathbf R_k)^\top\)</span></h3>
<p>We have a list called <code>H2l</code> which contains all possible
two-way terms <code>Hi %*% Hj + Hj %*% Hi</code>,
<code>i,j = 1,...,h</code> which arises as a result of squaring
<code>H = H1 + ... + Hh</code>. It is efficient to calculate these
two-way terms once at the beginning and then recall them as needed. For
our example, the entries of this list consist of</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>ind <span class="ot">&lt;-</span> <span class="fu">paste</span>(ind1, ind2, <span class="at">sep =</span> <span class="st">&quot;x&quot;</span>)</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="fu">names</span>(ind) <span class="ot">&lt;-</span> <span class="fu">as.character</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(ind))</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>ind</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="do">##     1     2     3 </span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="do">## &quot;1x2&quot; &quot;1x3&quot; &quot;2x3&quot;</span></span></code></pre></div>
<p>For clarity, in this example we rename the entries of
<code>ind</code> to reflect the three unique scale parameters, as
follows:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>ind.tmp</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="do">##     1     2     3 </span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="do">## &quot;1x2&quot; &quot;1x3&quot; &quot;2x3&quot;</span></span></code></pre></div>
<p>To remind ourselves, the matrices <span class="math inline">\(\mathbf
P_k\)</span>, <span class="math inline">\(\mathbf R_k\)</span> and the
product <span class="math inline">\(\mathbf P_k \mathbf R_k\)</span> are
defined as</p>
<p><span class="math display">\[
\begin{align}
    \mathbf P_k &amp;= \mathbf H_k +  \sum_{j\in M}\lambda_j\mathbf
H_{kj} \\
    \mathbf R_k &amp;= \sum_{j\neq k} \lambda_j \mathbf H_j \\
    \mathbf P_k \mathbf R_k &amp;= \sum_{j\neq k} \lambda_j \mathbf
H_k\mathbf H_j + \sum_{j\in M} \sum_{j&#39;\neq k}
\lambda_j\lambda_{j&#39;} \mathbf H_{kj} \mathbf H_{j&#39;}
\end{align}
\]</span></p>
<p>For now, ignore the scale parameters in the formulae above, and just
concentrate on the kernel matrices. For the first part of <span class="math inline">\(\mathbf P_k \mathbf R_k\)</span>, we require the
matrix product indices where variables <span class="math inline">\(k\)</span> is multiplied with all other variables
except itself. We call this <code>za</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>(za <span class="ot">&lt;-</span> <span class="fu">which</span>((ind1 <span class="sc">%in%</span> k <span class="sc">&amp;</span> ind2 <span class="sc">%in%</span> nok) <span class="sc">|</span> (ind2 <span class="sc">%in%</span> k <span class="sc">&amp;</span> ind1 <span class="sc">%in%</span> nok)))</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="do">## [1] 1 2</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co"># Check</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>ind[za]</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a><span class="do">##     1     2 </span></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="do">## &quot;1x2&quot; &quot;1x3&quot;</span></span></code></pre></div>
<p>For the second part, it is a double sum of the products of the
Hadamard matrices involving variable <code>k</code>, and all the kernel
matrices except <code>k</code>. We have already coded the indices as
<code>k.int</code> and <code>nok</code> respectively. Note that these
indices are in relation to the full index <code>1, 2, ..., 6</code>. In
<code>R</code>, we can use the <code>expand.grid()</code> function to
create a data frame from all possible combinations of <code>k.int</code>
and <code>nok</code>, which would give us the index of the double sum.
We then find the positions of these coordinates in <code>ind1</code> and
<code>ind2</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>(grid.PR <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(k.int, nok))</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="do">##   Var1 Var2</span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="do">## 1    4    2</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="do">## 2    5    2</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="do">## 3    4    3</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a><span class="do">## 4    5    3</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>(zb <span class="ot">&lt;-</span> <span class="fu">which</span>((ind1 <span class="sc">%in%</span> grid.PR[,<span class="dv">1</span>] <span class="sc">&amp;</span> ind2 <span class="sc">%in%</span> grid.PR[,<span class="dv">2</span>]) <span class="sc">|</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>            (ind2 <span class="sc">%in%</span> grid.PR[,<span class="dv">1</span>] <span class="sc">&amp;</span> ind1 <span class="sc">%in%</span> grid.PR[,<span class="dv">2</span>])</span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a>))</span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="do">## integer(0)</span></span></code></pre></div>
<p>Finally, what’s left is to take care of the scale parameters. Our
scale parameters are contained in the vector of length <code>q=6</code>
called <code>lambda</code>. For the first part, that is simply the index
<code>nok</code>. For the second part, we need to find the indices using
<code>expand.grid()</code> again, but this time using the indices
<code>k.int.lam</code> and <code>nok</code>. <code>k.int.lam</code>
would give us the indices of the scale parameters which have
interactions with <code>k</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>(nok)</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="do">## [1] 2 3</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>(grid.PR.lam <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(k.int.lam, nok))</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="do">##   Var1 Var2</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a><span class="do">## 1    2    2</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a><span class="do">## 2    3    2</span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a><span class="do">## 3    2    3</span></span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a><span class="do">## 4    3    3</span></span></code></pre></div>
<p>The required product <span class="math inline">\(\mathbf P_k \mathbf
R_k\)</span> is then, in a manner of speaking,</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="fu">sum</span>(lambda[PR.lam index] <span class="sc">*</span> H2l[PR index])</span></code></pre></div>
</div>
<div id="indices-for-mathbf-p_k-mathbf-u_k-mathbf-p_k-mathbf-u_ktop" class="section level3">
<h3>Indices for <span class="math inline">\(\mathbf P_k \mathbf U_k
+(\mathbf P_k \mathbf U_k)^\top\)</span></h3>
<p>The formulae of interest are</p>
<p><span class="math display">\[
\begin{align}
    \mathbf P_k &amp;= \mathbf H_k +  \sum_{j\in M}\lambda_j\mathbf
H_{kj} \\
    \mathbf U_k &amp;= \mathop{\sum\sum}_{k&#39;,j \in M \ \&amp; \
k&#39;\neq k} \lambda_{k&#39;} \lambda_j \mathbf H_{k&#39;j} \\
    \mathbf P_k \mathbf U_k &amp;= \mathop{\sum\sum}_{k&#39;,j \in M \
\&amp; \ k&#39;\neq k} \lambda_j \lambda_{k&#39;} \mathbf H_k \mathbf
H_{k&#39;j} + \mathop{\sum\sum}_{j,k&#39;,j&#39; \in M \ \&amp; \
k&#39;\neq k} \lambda_j \lambda_{k&#39;} \lambda_{j&#39;} \mathbf H_{kj}
\mathbf H_{k&#39;j&#39;}
\end{align}
\]</span></p>
<p>The idea is similar to the above, albeit the indices can be a bit
confusing. For the first part of the sum, we need the indices of the
double sum involving <code>k.noint</code> paired with <code>k</code>.
Recall that <code>k.noint</code> are the indices of the Hadamard
products which do not involve variable <code>k</code> (mathematically,
it is the set <span class="math inline">\(\{(k&#39;,j) \in M : k&#39;
\neq k\}\)</span>). We then find the corresponding index from
<code>ind1</code> and <code>ind2</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>(grid.PU1 <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(k, k.noint))</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="do">##   Var1 Var2</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="do">## 1    1    6</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>(zc <span class="ot">&lt;-</span> <span class="fu">which</span>((ind1 <span class="sc">%in%</span> grid.PU1[,<span class="dv">1</span>] <span class="sc">&amp;</span> ind2 <span class="sc">%in%</span> grid.PU1[,<span class="dv">2</span>]) <span class="sc">|</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>             (ind2 <span class="sc">%in%</span> grid.PU1[,<span class="dv">1</span>] <span class="sc">&amp;</span> ind1 <span class="sc">%in%</span> grid.PU1[,<span class="dv">2</span>])))</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="do">## integer(0)</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a><span class="co"># Check</span></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>ind[zc]</span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a><span class="do">## named character(0)</span></span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a>ind.tmp[zc]</span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a><span class="do">## named character(0)</span></span></code></pre></div>
<p>For the second part, we use <code>expand.grid()</code> to find the
indices for the double sum involving <code>k.int</code> (the Hadamard
products involving <code>k</code>) and <code>k.noint</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>(grid.PU2 <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(k.int, k.noint))</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="do">##   Var1 Var2</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a><span class="do">## 1    4    6</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a><span class="do">## 2    5    6</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a>(zd <span class="ot">&lt;-</span> <span class="fu">which</span>((ind1 <span class="sc">%in%</span> grid.PU2[,<span class="dv">1</span>] <span class="sc">&amp;</span> ind2 <span class="sc">%in%</span> grid.PU2[,<span class="dv">2</span>]) <span class="sc">|</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a>             (ind2 <span class="sc">%in%</span> grid.PU2[,<span class="dv">1</span>] <span class="sc">&amp;</span> ind1 <span class="sc">%in%</span> grid.PU2[,<span class="dv">2</span>])))</span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a><span class="do">## integer(0)</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a><span class="co"># Check</span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a>ind[zd]</span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a><span class="do">## named character(0)</span></span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a>ind.tmp[zd]</span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a><span class="do">## named character(0)</span></span></code></pre></div>
<p>Finally, we need to take care of the scale parameters. For the first
part, we only require the index from <code>k.noint</code>, while for the
second part we need the combinations of <code>k.int.lam</code> (indices
of the scale parameters which have interactions with k) and
<code>k.noint</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>(k.noint)</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a><span class="do">## [1] 6</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>(grid.PU.lam <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(k.int.lam, k.noint))</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="do">##   Var1 Var2</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="do">## 1    2    6</span></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="do">## 2    3    6</span></span></code></pre></div>
</div>
<div id="calculation-of-mathbf-s_k" class="section level3">
<h3>Calculation of <span class="math inline">\(\mathbf S_k\)</span></h3>
<p>The matrix <span class="math inline">\(\mathbf S_k\)</span> is given
by the formula</p>
<p><span class="math display">\[
  \mathbf S_k = \mathbf P_k\mathbf R_k + (\mathbf P_k\mathbf R_k)^\top +
\mathbf P_k\mathbf U_k + (\mathbf P_k\mathbf U_k)^\top.
\]</span></p>
<p>As <span class="math inline">\(\mathbf P_k\mathbf R_k\)</span> and
<span class="math inline">\(\mathbf P_k\mathbf U_k\)</span> are made up
linearly of two-way matrix products of the kernel matrices which are
stored in <code>H2l</code>, all we need is to add the right entries of
<code>H2l</code> together (and not forgetting the respective scale
parameters). The indices are given by the function
<code>indxFn()</code>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>indB <span class="ot">&lt;-</span> <span class="fu">indxFn</span>(<span class="dv">1</span>)</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>indB<span class="sc">$</span>PRU  <span class="co"># = c(za, zc, zb, zd) i.e. index of Hl to sum together</span></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a><span class="do">## [1] 1 2</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a><span class="fu">rbind</span>(indB<span class="sc">$</span>PRU.lam1, indB<span class="sc">$</span>PRU.lam2)  <span class="co"># index of the lambdas to cross-product with Hl</span></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a><span class="do">##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]</span></span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a><span class="do">## [1,]    0    0    0    2    3    2    3    2    3</span></span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a><span class="do">## [2,]    2    3    6    2    2    3    3    6    6</span></span></code></pre></div>
<p>For <code>k=1</code>, we calculate <span class="math inline">\(\mathbf S_1\)</span> as</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>lambda.PRU <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">1</span>, <span class="fu">sum</span>(indB<span class="sc">$</span>PRU.lam1 <span class="sc">==</span> <span class="dv">0</span>)), lambda[indB<span class="sc">$</span>PRU.lam1])</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>lambda.PRU <span class="ot">&lt;-</span> lambda.PRU <span class="sc">*</span> lambda[indB<span class="sc">$</span>PRU.lam2]</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>S <span class="ot">&lt;-</span> <span class="fu">Reduce</span>(<span class="st">&quot;+&quot;</span>, <span class="fu">mapply</span>(<span class="st">&quot;*&quot;</span>, H2l[indB<span class="sc">$</span>PRU], lambda.PRU, <span class="at">SIMPLIFY =</span> <span class="cn">FALSE</span>))</span></code></pre></div>
<p>This is an efficient way to calculate <span class="math inline">\(\mathbf S_k\)</span> by simply recalling the
already multiplied matrices. In the EM algorithm, we would need to
repeat this calculation for each <code>k=1,...,l</code> and also for
each EM step <code>t=1,2,...</code>.</p>
<p>Note that <span class="math inline">\(\mathbf S_k\)</span> is
calculated this way only if there are parsimonious interactions. When
only a single scale paramters is used (e.g. using
<code>one.lam = TRUE</code>), then <span class="math inline">\(\mathbf
S_k = 0\)</span>. When no interactions are present, then <span class="math inline">\(\mathbf U_k = 0\)</span>, and we only need <span class="math inline">\(\mathbf P_k \mathbf R_k + (\mathbf P_k \mathbf
R_k)^\top\)</span>. But this becomes easier because <span class="math inline">\(\mathbf P_k = \mathbf H_k\)</span> as there are no
Hadamard interactions.</p>
<p>Also realise that we never calculate <span class="math inline">\(\mathbf R_k\)</span> and <span class="math inline">\(\mathbf U_k\)</span> explicitly, because only
<span class="math inline">\(\mathbf S_k\)</span> is required in the
closed form expression of <span class="math inline">\(\lambda_k^{(t+1)}\)</span>.</p>
</div>
<div id="efficient-calculation-of-mathbf-p_k2" class="section level3">
<h3>Efficient calculation of <span class="math inline">\(\mathbf
P_k^2\)</span></h3>
<p>When (parsimonious) interactions are present, <span class="math inline">\(\mathbf P_k^2\)</span> is given by</p>
<!-- $$ -->
<!-- \begin{align} -->
<!--   \mathbf P_k^2 &= (\mathbf H_k + \sum_{j\in M}\lambda_j\mathbf H_{kj})^2 \\ -->
<!--   &= \mathbf H_k^2 + \sum_{j\in M} \lambda_j^2 \mathbf H_{kj}^2 +  -->
<!--   \sum_{j\in M}\lambda_j (\mathbf H_k\mathbf H_{kj} + \mathbf H_{kj}\mathbf H_k) \\ -->
<!-- \end{align} -->
<!-- $$ -->
<p>This sum is made of two parts. The first is by adding up relevant
squared kernel matrices and Hadamard products. We can collate these
matrix products into a list of length <code>h = l + m</code> called
<code>Hsql</code>. The second part comes from <code>H2l</code> as we
have discussed above. Now it is a matter of summing up the right
parts.</p>
<p>For <code>k=1</code>, the first part is getting the indices of the
squared terms correctly. This is easy as we have already obtained this
previously.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>(Psq <span class="ot">&lt;-</span> <span class="fu">c</span>(k, k.int))</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a><span class="do">## [1] 1 4 5</span></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>(Psq.lam <span class="ot">&lt;-</span> k.int.lam)</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a><span class="do">## [1] 2 3</span></span></code></pre></div>
<p>For the second part, we use <code>combn()</code> to generate all
possible two-way combinations of <code>c(k, k.int)</code>. This would
give us the indices for the sums in the second part above. The
corresponding scale paramters <code>lambda</code> are obtained the same
way, but from all possible combinations of <code>c(0, k.int.lam)</code>.
The two columns of <code>grid.Psq.lam</code> give the index for which
<code>lambda</code> needs to be multiplied. An entry of <code>0</code>
means that only the other non-zero column entry is used, e.g. for
<code>grid.Psq.lam[1,]</code>, we multiply <code>1 * lambda[2]</code>;
for <code>grid.Psq.lam[3,]</code>, we multiply
<code>lambda[2] * lambda[3]</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>(grid.Psq <span class="ot">&lt;-</span> <span class="fu">t</span>(<span class="fu">combn</span>(<span class="fu">c</span>(k, k.int), <span class="dv">2</span>)))</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a><span class="do">##      [,1] [,2]</span></span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a><span class="do">## [1,]    1    4</span></span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a><span class="do">## [2,]    1    5</span></span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a><span class="do">## [3,]    4    5</span></span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a>(ze <span class="ot">&lt;-</span> <span class="fu">which</span>((ind1 <span class="sc">%in%</span> grid.Psq[,<span class="dv">1</span>] <span class="sc">&amp;</span> ind2 <span class="sc">%in%</span> grid.Psq[,<span class="dv">2</span>]) <span class="sc">|</span></span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a>             (ind2 <span class="sc">%in%</span> grid.Psq[,<span class="dv">1</span>] <span class="sc">&amp;</span> ind1 <span class="sc">%in%</span> grid.Psq[,<span class="dv">2</span>])))</span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a><span class="do">## integer(0)</span></span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a><span class="co"># Check</span></span>
<span id="cb22-11"><a href="#cb22-11" tabindex="-1"></a>ind[ze]</span>
<span id="cb22-12"><a href="#cb22-12" tabindex="-1"></a><span class="do">## named character(0)</span></span>
<span id="cb22-13"><a href="#cb22-13" tabindex="-1"></a>ind.tmp[ze]</span>
<span id="cb22-14"><a href="#cb22-14" tabindex="-1"></a><span class="do">## named character(0)</span></span>
<span id="cb22-15"><a href="#cb22-15" tabindex="-1"></a></span>
<span id="cb22-16"><a href="#cb22-16" tabindex="-1"></a>grid.Psq.lam <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb22-17"><a href="#cb22-17" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">length</span>(k.int.lam) <span class="sc">&gt;</span> <span class="dv">0</span>) grid.Psq.lam <span class="ot">&lt;-</span> <span class="fu">t</span>(<span class="fu">combn</span>(<span class="fu">c</span>(<span class="dv">0</span>, k.int.lam), <span class="dv">2</span>))</span>
<span id="cb22-18"><a href="#cb22-18" tabindex="-1"></a>grid.Psq.lam</span>
<span id="cb22-19"><a href="#cb22-19" tabindex="-1"></a><span class="do">##      [,1] [,2]</span></span>
<span id="cb22-20"><a href="#cb22-20" tabindex="-1"></a><span class="do">## [1,]    0    2</span></span>
<span id="cb22-21"><a href="#cb22-21" tabindex="-1"></a><span class="do">## [2,]    0    3</span></span>
<span id="cb22-22"><a href="#cb22-22" tabindex="-1"></a><span class="do">## [3,]    2    3</span></span></code></pre></div>
<p>The code, which is found in the function for <code>kernL()</code>, is
given by</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="co"># First part of sum</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>Psql[[k]] <span class="ot">&lt;&lt;-</span> <span class="fu">Reduce</span>(<span class="st">&quot;+&quot;</span>, <span class="fu">mapply</span>(<span class="st">&quot;*&quot;</span>, Hsql[indB<span class="sc">$</span>Psq],</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>                                 <span class="fu">c</span>(<span class="dv">1</span>, lambda[indB<span class="sc">$</span>Psq.lam] <span class="sc">^</span> <span class="dv">2</span>),</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>                                 <span class="at">SIMPLIFY =</span> <span class="cn">FALSE</span>))</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a><span class="co"># Second part of sum</span></span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>lambda.P2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">1</span>, <span class="fu">sum</span>(indB<span class="sc">$</span>P2.lam1 <span class="sc">==</span> <span class="dv">0</span>)), lambda[indB<span class="sc">$</span>P2.lam1])</span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a>lambda.P2 <span class="ot">&lt;-</span> lambda.P2 <span class="sc">*</span> lambda[indB<span class="sc">$</span>P2.lam2]</span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a>Psql[[k]] <span class="ot">&lt;&lt;-</span> Psql[[k]] <span class="sc">+</span> <span class="fu">Reduce</span>(<span class="st">&quot;+&quot;</span>, <span class="fu">mapply</span>(<span class="st">&quot;*&quot;</span>, H2l[indB<span class="sc">$</span>P2],</span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a>                                             lambda.P2,</span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a>                                             <span class="at">SIMPLIFY =</span> <span class="cn">FALSE</span>))</span></code></pre></div>
<p>Note that in cases where there are no interactions (or with
non-parsimonious interactions), then <span class="math inline">\(\mathbf
P_k^2 = \mathbf H_k^2\)</span> and does not depend on <span class="math inline">\(\lambda_k\)</span>, thus can be calculated once
and stored.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
